# Comprehensive Mach Language Test File
# This file demonstrates every syntax feature from the language specification

# External imports
use std.io;
use math: std.math;

# External function declarations
ext printf: fun(*any, ...) i32;
ext malloc: fun(u64) *any;
ext free: fun(*any) any;

# Type definitions and aliases
def byte: u8;
def word: u16;
def dword: u32;
def qword: u64;
def float: f32;
def double: f64;

# Function type definitions
def unary_op: fun(f32) f32;
def binary_op: fun(f32, f32) f32;
def callback: fun(i32, *u8) void;
def logger: fun([_]u8, ...) void;

# Compile-time constants
val PI: f32 = 3.14159265359;
val MAX_SIZE: u32 = 1024;
val VERSION: u8 = 1;
val BUFFER_SIZE: u64 = 4096;

# Struct definitions
def point: str {
    x: f32;
    y: f32;
    z: f32;
};

def rectangle: str {
    top_left: point;
    bottom_right: point;
    area: f32;
};

def node: str {
    data: i32;
    next: *node;
    prev: *node;
};

def complex_struct: str {
    id: u64;
    name: [32]u8;
    position: point;
    children: [10]*node;
    metadata: *u8;
};

# Union definitions
def number: uni {
    as_int: i32;
    as_float: f32;
    as_bytes: [4]u8;
};

def variant: uni {
    integer: i64;
    floating: f64;
    pointer: *u8;
    array: [8]u8;
};

# Explicit casting examples - :: operator for same-size type reinterpretation
# NOTE: Mach avoids implicit casting. Only literals can be implicitly cast.
# Variables must use explicit casting with :: for same-size type reinterpretation.
val literal_to_int: i32 = 42;           # Literal implicitly cast to i32
val literal_to_float: f32 = 3.14;       # Literal implicitly cast to f32
val int_as_float: f32 = literal_to_int::f32;  # Explicit cast: i32 to f32 (both 4 bytes)
val float_as_int: i32 = literal_to_float::i32; # Explicit cast: f32 to i32 (both 4 bytes)
val hex_as_float: f32 = 0x41200000::f32;       # Hex literal cast to float (10.0f)

# Global variables
var global_counter: u32 = 0;
var global_buffer: [1024]u8 = [1024]u8{0};
var global_points: [_]point = [_]point{
    point{1.0, 2.0, 3.0},
    point{4.0, 5.0, 6.0},
    point{7.0, 8.0, 9.0}
};

# Simple function with basic arithmetic
fun add(a: i32, b: i32) i32 {
    ret a + b;
}

fun subtract(a: i32, b: i32) i32 {
    ret a - b;
}

fun multiply(a: i32, b: i32) i32 {
    ret a * b;
}

fun divide(a: i32, b: i32) i32 {
    if (b == 0) {
        ret 0;
    }
    ret a / b;
}

fun modulus(a: i32, b: i32) i32 {
    ret a % b;
}

# Function demonstrating all comparison operators
fun compare_values(a: i32, b: i32) u8 {
    val equal: u8 = a == b;
    val not_equal: u8 = a != b;
    val less_than: u8 = a < b;
    val less_equal: u8 = a <= b;
    val greater_than: u8 = a > b;
    val greater_equal: u8 = a >= b;
    
    ret equal || not_equal || less_than || less_equal || greater_than || greater_equal;
}

# Function demonstrating logical operators
fun logical_operations(a: u8, b: u8) u8 {
    val and_result: u8 = a && b;
    val or_result: u8 = a || b;
    val not_a: u8 = !a;
    val not_b: u8 = !b;
    
    ret and_result || or_result || not_a || not_b;
}

# Function demonstrating bitwise operations
fun bitwise_operations(a: u32, b: u32) u32 {
    val and_bits: u32 = a & b;
    val or_bits: u32 = a | b;
    val xor_bits: u32 = a ^ b;
    val not_bits: u32 = ~a;
    val left_shift: u32 = a << 2;
    val right_shift: u32 = a >> 2;
    
    ret and_bits + or_bits + xor_bits + not_bits + left_shift + right_shift;
}

# Function demonstrating control flow with if/or
fun control_flow_example(value: i32) i32 {
    if (value < 0) {
        ret -1;
    }
    or (value == 0) {
        ret 0;
    }
    or (value > 100) {
        ret 100;
    }
    or {
        ret value;
    }
}

# Function demonstrating for loops
fun loop_examples() i32 {
    var sum: i32 = 0;
    var i: i32 = 0;
    
    # Basic for loop with condition
    for (i < 10) {
        sum = sum + i;
        i = i + 1;
    }
    
    # Infinite loop with break and continue
    var j: i32 = 0;
    for {
        if (j % 2 == 0) {
            j = j + 1;
            cnt;
        }
        
        if (j > 20) {
            brk;
        }
        
        sum = sum + j;
        j = j + 1;
    }
    
    ret sum;
}

# Function demonstrating pointers and dereferencing
fun pointer_operations() i32 {
    var value: i32 = 42;
    var ptr: *i32 = ?value;        # Get address of value
    var deref: i32 = @ptr;         # Dereference pointer
    
    @ptr = 100;                    # Set value through pointer
    
    # Pointer arithmetic
    var array: [5]i32 = [5]i32{1, 2, 3, 4, 5};
    var array_ptr: *i32 = ?array[0];
    array_ptr = array_ptr + 1;     # Move to next element
    var second_element: i32 = @array_ptr;
    
    ret value + deref + second_element;
}

# Function demonstrating arrays
fun array_operations() i32 {
    # Fixed size arrays
    var fixed_array: [5]i32 = [5]i32{1, 2, 3, 4, 5};
    
    # Dynamic size arrays
    var dynamic_array: [_]i32 = [_]i32{10, 20, 30, 40, 50, 60};
    
    # Array indexing
    var first: i32 = fixed_array[0];
    var last: i32 = dynamic_array[5];
    
    # Array length using builtin
    val fixed_len: u32 = len(fixed_array);
    val dynamic_len: u32 = len(dynamic_array);
    
    ret first + last + fixed_len + dynamic_len;
}

# Function demonstrating struct operations
fun struct_operations() f32 {
    var p1: point = point{1.0, 2.0, 3.0};
    var p2: point = point{4.0, 5.0, 6.0};
    
    # Struct field access
    var x_sum: f32 = p1.x + p2.x;
    var y_sum: f32 = p1.y + p2.y;
    var z_sum: f32 = p1.z + p2.z;
    
    # Nested struct
    var rect: rectangle = rectangle{
        point{0.0, 0.0, 0.0},
        point{10.0, 10.0, 0.0},
        100.0
    };
    
    var area: f32 = rect.area;
    var corner_x: f32 = rect.top_left.x;
    
    ret x_sum + y_sum + z_sum + area + corner_x;
}

# Function demonstrating union operations
fun union_operations() i32 {
    var num: number = number{};
    num.as_int = 42;
    
    var float_view: f32 = num.as_float;
    var byte_view: u8 = num.as_bytes[0];
    
    # Type punning through union
    var variant_data: variant = variant{};
    variant_data.integer = 0x12345678;
    var first_byte: u8 = variant_data.array[0];
    
    ret num.as_int + byte_view + first_byte;
}

# Function demonstrating builtin functions
fun builtin_functions() u32 {
    # Type introspection
    val size_i32: u32 = size_of(i32);
    val align_i32: u32 = align_of(i32);
    val size_point: u32 = size_of(point);
    val align_point: u32 = align_of(point);
    
    # Struct field offset
    val offset_x: u32 = offset_of(point.x);
    val offset_y: u32 = offset_of(point.y);
    val offset_z: u32 = offset_of(point.z);
    
    # Array length
    var test_array: [100]f64 = [100]f64{0.0};
    val array_length: u32 = len(test_array);
    
    ret size_i32 + align_i32 + size_point + align_point + 
        offset_x + offset_y + offset_z + array_length;
}

# Function demonstrating explicit type casting with ::
fun type_casting() i64 {
    var int_val: i32 = 42;
    var float_val: f32 = 3.14;
    
    # Explicit casting between same-size types using ::
    var float_as_int: i32 = float_val::i32;     # f32 to i32 (both 4 bytes)
    var int_as_float: f32 = int_val::f32;       # i32 to f32 (both 4 bytes)
    
    # Casting between different integer types of same size
    var signed_val: i32 = -1;
    var unsigned_val: u32 = signed_val::u32;    # i32 to u32 (both 4 bytes)
    var back_to_signed: i32 = unsigned_val::i32; # u32 back to i32
    
    # Casting with 64-bit types
    var long_val: i64 = 0x123456789ABCDEF0;
    var double_val: f64 = long_val::f64;        # i64 to f64 (both 8 bytes)
    var back_to_long: i64 = double_val::i64;    # f64 back to i64
    
    # Pointer casting
    var int_ptr: *i32 = ?int_val;
    var byte_ptr: *u8 = int_ptr::*u8;           # *i32 to *u8 (same pointer size)
    var void_ptr: *u8 = int_ptr::*u8;           # Generic pointer cast
    
    # Array element casting
    var bytes: [4]u8 = [4]u8{0x12, 0x34, 0x56, 0x78};
    var as_int: i32 = bytes::i32;               # [4]u8 to i32 (same 4 bytes)
    
    # Union-style casting through explicit cast
    var hex_value: u32 = 0x41200000;            # IEEE 754 representation of 10.0f
    var as_float: f32 = hex_value::f32;         # Reinterpret bits as float
    
    # Note: These would be compile errors (different sizes):
    # var bad_cast1: i64 = int_val::i64;        # Error: i32 (4 bytes) to i64 (8 bytes)
    # var bad_cast2: i16 = int_val::i16;        # Error: i32 (4 bytes) to i16 (2 bytes)
    # var bad_cast3: f64 = float_val::f64;      # Error: f32 (4 bytes) to f64 (8 bytes)
    
    ret back_to_long + as_int + as_float::i32;
}

# Function demonstrating function pointers
fun function_pointer_example() i32 {
    # Function pointer assignment
    var op: binary_op = add;
    var result1: i32 = op(10, 20);
    
    # Change function pointer
    op = multiply;
    var result2: i32 = op(5, 6);
    
    ret result1 + result2;
}

# Function demonstrating variadic arguments
fun sum_integers(count: i32, args: ...) i32 {
    var total: i32 = 0;
    var i: u32 = 0;
    
    # Check that we have the expected number of arguments
    if (len(args) != count) {
        ret -1;
    }
    
    for (i < len(args)) {
        total = total + args[i]::i32;
        i = i + 1;
    }
    
    ret total;
}

# Function demonstrating printf-style formatting
fun debug_log(level: i32, format: [_]u8, args: ...) void {
    if (level > 0) {
        # Simple format processing - handle %d and %s
        var arg_index: u32 = 0;
        var i: u32 = 0;
        
        for (i < len(format)) {
            if (format[i] == '%' && i + 1 < len(format)) {
                i = i + 1;
                if (format[i] == 'd' && arg_index < len(args)) {
                    var value: i32 = args[arg_index]::i32;
                    # Output integer (simplified)
                    arg_index = arg_index + 1;
                } or (format[i] == 's' && arg_index < len(args)) {
                    var value: [_]u8 = args[arg_index]::[_]u8;
                    # Output string (simplified)
                    arg_index = arg_index + 1;
                }
            }
            i = i + 1;
        }
    }
}

# Function demonstrating mixed argument types
fun log_values(title: [_]u8, args: ...) void {
    # Demonstrate accessing different types from variadic args
    var i: u32 = 0;
    for (i < len(args)) {
        # In a real implementation, you'd need type information
        # For demo purposes, assume alternating i32 and f32
        if (i % 2 == 0) {
            var int_val: i32 = args[i]::i32;
            # Process integer
        } or {
            var float_val: f32 = args[i]::f32;
            # Process float
        }
        i = i + 1;
    }
}

# Complex function demonstrating multiple features
fun complex_algorithm(data: *i32, size: u32, threshold: i32) i32 {
    if (data == 0x0 || size == 0) {
        ret -1;
    }
    
    var count: i32 = 0;
    var sum: i32 = 0;
    var i: u32 = 0;
    
    for (i < size) {
        var current: i32 = @(data + i);
        
        if (current > threshold) {
            sum = sum + current;
            count = count + 1;
        }
        or (current < 0) {
            # Skip negative values
            i = i + 1;
            cnt;
        }
        or {
            # Include in sum but don't count
            sum = sum + current;
        }
        
        i = i + 1;
        
        if (count > 100) {
            brk;
        }
    }
    
    ret sum / (count + 1);
}

# Entry point function
fun main() i32 {
    # Test all functionality
    var arithmetic_result: i32 = add(10, 20) + multiply(5, 6);
    var comparison_result: u8 = compare_values(10, 20);
    var logical_result: u8 = logical_operations(1, 0);
    var bitwise_result: u32 = bitwise_operations(0xFF, 0x0F);
    var control_result: i32 = control_flow_example(50);
    var loop_result: i32 = loop_examples();
    var pointer_result: i32 = pointer_operations();
    var array_result: i32 = array_operations();
    var struct_result: f32 = struct_operations();
    var union_result: i32 = union_operations();
    var builtin_result: u32 = builtin_functions();
    var casting_result: i64 = type_casting();
    var function_ptr_result: i32 = function_pointer_example();
    var variadic_result: i32 = sum_integers(3, 10, 20, 30);
    
    # Test debug logging
    debug_log(1, "Testing variadic: %d %s", 42, "Hello");
    
    # Test mixed types
    log_values("Mixed values:", 100, 3.14, 200, 2.71);
    
    # Test complex algorithm
    var test_data: [10]i32 = [10]i32{1, 5, 10, 15, 20, 25, 30, 35, 40, 45};
    var complex_result: i32 = complex_algorithm(?test_data[0], 10, 20);
    
    # Combine all results
    var total: i32 = arithmetic_result + comparison_result + logical_result + 
                     bitwise_result + control_result + loop_result + 
                     pointer_result + array_result + struct_result + 
                     union_result + builtin_result + casting_result + 
                     function_ptr_result + complex_result + variadic_result;
    
    ret total;
}
