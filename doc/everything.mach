# Comprehensive Mach Language Test File
# This file demonstrates every syntax feature from the language specification

# imports
use std.io; # unaliased -- all symbols from `std.io` are directly accessible
use math: std.math; # aliased import -- symbols from `std.math` are accessed with `math.` prefix

# external function statements
ext malloc: fun(u64) ptr;

# type definition and aliasing
def byte: u8;

# function type definitions
def binary_op: fun(i32, i32) i32;

# compile-time constants
val PI: f32 = 3.14159265359;

# struct definitions
str point {
    x: f32;
    y: f32;
}

str dot {
    x: f32;
    y: f32;
}

# alternative struct definition
def rect: str {
    top_left: point;
    bottom_right: point;
    area: f32;
};

# union definitions
uni number {
    as_int: i32;
    as_float: f32;
    as_bytes: [4]u8;
}

# alternative union definition
def variant: uni {
    integer: i32;
    float: f32;
    array: [4]u8;
};

# nested structs and unions
str nested_example {
    position: point;
    data: uni {
        id: u32;
        name: [32]u8;
    };
    flags: u8;
}

# globals
val global_val: u32 = 1024;
var global_var: i32 = 100;

# casting examples - :: operator for same-size type reinterpretation
# NOTE: Mach avoids implicit casting. Only literals can be implicitly cast.
# Variables must use explicit casting with :: for same-size type reinterpretation.
val literal_to_int: i32 = 42;           # Literal implicitly cast to i32
val int_as_float: f32 = literal_to_int::f32;  # Explicit cast: i32 to f32 (both 4 bytes)

# function definition
fun add(a: i32, b: i32) i32 {
    ret a + b;
}

# pointers
fun pointer_operations() {
    var x: i32 = 42;
    var y: i32 = 100;

    # reference and pointer type
    var ptr_x: *i32 = ?x;

    # pointer arithmetic
    var ptr_y: *i32 = ptr_x + 1;

    # dereference
    var value_x: i32 = @ptr_x;
    var value_y: i32 = @ptr_y;

    # pointer casting
    var byte_ptr: *u8 = ptr_x::*u8;

    # pointer indexing
    var second_byte: u8 = byte_ptr[1]; # access second byte of the integer

    # direct memory address assignment
    var addr: *i32 = 0x1000::*i32;
    val nil: ptr = 0x0; # null pointer

    # array decay
    var arr: [5]i32 = [5]i32{1, 2, 3, 4, 5};
    var arr_ptr: *i32 = arr::*i32; # explicit decay to pointer
    var arr_ptr2: *i32 = ?arr[0]; # pointer to first element
    # var bad_decay: *i32 = arr; # this would be an error, as arrays do not decay implicitly
}

# arrays
fun array_operations() {
    # fixed-length array
    var arr: [5]i32 = [5]i32{1, 2, 3, 4, 5};

    # array length
    var arr_len: u32 = len(arr);

    # accessing elements
    var sum: i32 = 0;
    var i: u32 = 0;
    for (i < arr_len) {
        sum = sum + arr[i];
        i = i + 1;
    }

    # unbound array
    var arr_unbound: []f64 = []f64{1.0, 2.0, 3.0, 4.0, 5.0};
    var unbound_len: u32 = len(arr_unbound);
    var unbound_sum: f64 = 0.0;
    var j: u32 = 0;
    for (j < unbound_len) {
        unbound_sum = unbound_sum + arr_unbound[j];
        j = j + 1;
    }
}

# multi-dimensional arrays
fun multi_array_operations() {
    # 2d array
    var matrix: [3][3]i32 = [3][3]i32{
        [3]i32{1, 2, 3},
        [3]i32{4, 5, 6},
        [3]i32{7, 8, 9}
    };
    
    # access element
    var element: i32 = matrix[1][2];
    
    # 3d array
    var cube: [2][2][2]u8 = [2][2][2]u8{
        [2][2]u8{
            [2]u8{1, 2},
            [2]u8{3, 4}
        },
        [2][2]u8{
            [2]u8{5, 6},
            [2]u8{7, 8}
        }
    };
}

# struct initialization and access
fun struct_operations() {
    # initialize struct
    var p: point = point{
        x: 0.0,
        y: 0.0
    };

    var empty_point: point = point{}; # alternative empty initialization

    # access fields
    var area: f32 = p.x * p.y;  # Example operation

    # alternative initialization
    var r: rect = rect{};
    r.top_left = p;
    r.bottom_right = point{x: 20.0, y: 25.0};
    r.area = (r.bottom_right.x - r.top_left.x) * (r.bottom_right.y - r.top_left.y);
}

# union initialization and access
fun union_operations() {
    # initialize union
    var num: number = number{
        as_int: 42
    };

    # access union fields
    var int_value: i32 = num.as_int;
    var float_value: f32 = num.as_float;
    var byte_array: [4]u8 = num.as_bytes;
}

# builtins
fun builtin_functions() {
    # Type introspection
    val size_i32: u32 = size_of(i32);
    val align_i32: u32 = align_of(i32);
    val size_point: u32 = size_of(point);
    val align_point: u32 = align_of(point);
    
    # Struct field offset
    val offset_x: u32 = offset_of(point.x);
    val offset_y: u32 = offset_of(point.y);
    
    # array length
    var test_array: [100]f64 = [100]f64{0.0};
    val array_length: u32 = len(test_array);
}

# type casting
fun type_casting() {
    # numeric conversion (value changes)
    var a: i32 = 42;
    var b: f32 = a::f32;  # converts 42 to 42.0
    
    # bit reinterpretation (bits stay same)
    var bits: u32 = 0x3F800000;
    var as_float: f32 = bits::f32;  # reinterprets as 1.0
    
    # truncation
    var big: i32 = 0x12345678;
    var small: u8 = big::u8;  # truncates to 0x78
}

# operators
fun operators() {
    # arithmetic
    var sum: i32 = 10 + 20;
    var diff: i32 = 30 - 15;
    var prod: i32 = 5 * 6;
    var quot: i32 = 100 / 4;
    var mod: i32 = 10 % 3;

    # comparision
    var is_equal: u8 = (sum == diff);
    var is_greater: u8 = (prod > quot);
    var is_less: u8 = (mod < 5);
    var is_not_equal: u8 = (sum != diff);
    var is_greater_equal: u8 = (prod >= 30);
    var is_less_equal: u8 = (mod <= 3);

    # logical
    var and_result: u8 = (is_equal && is_greater);
    var or_result: u8 = (is_equal || is_greater);
    var not_result: u8 = !is_less;

    # bitwise
    var bit_and: u32 = 0xFF & 0x0F;
    var bit_or: u32 = 0xFF | 0x0F;
    var bit_xor: u32 = 0xFF ^ 0x0F;
    var bit_not: u32 = ~0xFF;
    var left_shift: u32 = 1 << 2;
    var right_shift: u32 = 4 >> 1;
}

# function calling
fun function_calls() {
    # simple function call
    var result: i32 = add(10, 20);

    # external function call
}

# control flow
fun control_flow() {
    # if-or
    var x: i32 = 10;
    if (x > 0) {
        # if block
        std.io.print("x is positive");
    }
    or (x < 0) {
        # or block
        std.io.print("x is negative");
    }
    or {
        # else block
        std.io.print("x is zero");
    }

    # loop
    var i: u32 = 0;
    for (i < 10) {
        i = i + 1;
    }

    # unbound loop
    for {
        if (i >= 5) {
            # loop break
            brk;
        }

        if (i == 3) {
            # loop continue
            cnt;
        }

        i = i + 1;
    }
}

# function pointers
fun function_pointers() {
    # assign function to variable
    var op: binary_op = add;

    # call through function pointer
    var result: i32 = op(5, 10);
}

# data types
fun data_types() {
    # unsigned integer types
    var u8_val: u8 = 255;
    var u16_val: u16 = 65535;
    var u32_val: u32 = 4294967295;
    var u64_val: u64 = 18446744073709551615;

    # signed integer types
    var i8_val: i8 = -128;
    var i16_val: i16 = -32768;
    var i32_val: i32 = -2147483648;
    var i64_val: i64 = -9223372036854775808;

    # floating-point types
    var f16_val: f16 = 1.0;
    var f32_val: f32 = 3.14;
    var f64_val: f64 = 2.718281828459045;

    # characters and strings
    var char_val: u8 = 'A';  # single character
    var string_val: []u8 = "Hello, Mach!";  # string literal

    # integer literal formats
    var hex_val: u32 = 0xFF;  # hexadecimal
    var bin_val: u32 = 0b101010;  # binary
    var oct_val: u32 = 0o77;  # octal
}
