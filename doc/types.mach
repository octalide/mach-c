# builtin basic types
# NOTE: These are the ONLY builtin basic types in mach.
val int_signed_8:    i8  = 0;
val int_signed_16:   i16 = 0;
val int_signed_32:   i32 = 0;
val int_signed_64:   i64 = 0;
val int_unsigned_8:  u8  = 0;
val int_unsigned_16: u16 = 0;
val int_unsigned_32: u32 = 0;
val int_unsigned_64: u64 = 0;
val float_32:        f32 = 0.0;
val float_64:        f64 = 0.0;

# type definition (and aliasing)
# NOTE: Type definitions are used to create new types or aliases for existing types. They are not able to be defined with a value.
def int8: i8;
def foo:  fun(u32) u32;

# structs
# NOTE: Structs are used to define custom data types with named fields.
# They can contain any type, including other structs, arrays, and unions.
# They are unable to contain a non-pointer self-referencing field.
str point {
    x:    f32;
    y:    f32;
    meta: *point; # pointer to another point struct
}

# union
# NOTE: Unions are used to define custom data types that can hold different types of values in the same memory space.
# They are similar to structs, but all fields share the same memory location.
uni foo {
    bar:  u32;
    baz:  f32;
    meta: *foo; # pointer to another foo union
}

# pointers
val a: *i32 = 0x0;        # 0x0, nil pointer
val b: i32  = @a;         # dereference pointer
val c: *i32 = ?b;         # address of int32
val d: *i32 = 0x12345678; # pointer to a memory address

# arrays
val arr:  [5]i32 = [5]i32{1, 2, 3, 4, 5}; # fixed size array
val arr2: [_]i32 = [_]i32{1, 2, 3, 4, 5}; # dynamic size array

# casting
# NOTE: casting is special in mach. any type with an identical memory size can be cast to another type.
# this is not a "type conversion", but a reinterpretation of the memory.
# this means that casting between signed and unsigned types is allowed, as well as between integers and floats.
val casted:  i32 = 0x12345678::i32; # explicit cast of literal to i32
val casted2: f32 = casted::f32;     # reinterpretation of the memory as float
